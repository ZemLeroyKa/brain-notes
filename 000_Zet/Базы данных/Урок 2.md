
DBeaver
PGAdmin

Размер базы данных
- начальный размер
- автоматическое приращение размера
- максимальный размер БД


При создании таблицы мы указываем первичный ключ.
Существует возможность получения уникального значения первичного ключа путём задания автоматического инкрементирования значения в требуемом поле. 
- Increment
- Seed - стартовое значение (например, 1 000 000)

Уникальность - параметр для атрибута, который защищает запись в строку, если значение поля с заданной уникальностью уже существует в другой записи в этом столбце. 

# Типы данных в SQL
## Целочисленные типы данных
- точные числовые значения, 
- возраст,
- количество единиц товара

| Название | Диапазон                                                   | Память |
| -------- | ---------------------------------------------------------- | ------ |
| bigint   | от -9 223 372 036 854 775 808 до 9 223 372 036 854 775 807 | 8      |
| int      | от -2147483648 до 2147483647                               | 4      |
| smallint | от -32768 до 32767                                         | 2      |
| tinyint  | от 0 до 255                                                | 1      |
| bit      | 0, 1, NULL                                                 | 1      |


## Типы данных для хранения текста

`char(n)` — хранение строк *фиксированной* длины *не в кодировке* Unicode. n — возможное количество символов в строке от 1 до 8000. На каждый символ выделяется 1 байт. 

`varchar(n | max)` — хранение строк *переменной* длины (*не в кодировке* Unicode). n — возможное количество символов в строке от 1 до 8000. На каждый символ выделяется 1 байт. Если указан max, вместо n, то для хранения строки выделится память до 2 Гб 

`nchar(n)` — хранение строк *фиксированной* длины *в кодировке* Unicode. n — возможное количество символов в строке от 1 до 4000. На каждый символ выделяется 2 байт.
 
`nvarchar(n | max)` — хранение строк *переменной* длины *в кодировке* Unicode. n — возможное количество символов в строке от 1 до 4000. На каждый символ выделяется 2 байт. Если указан max, вместо n, то для хранения строки выделится память до 2 Гб.

## Вещественные типы данных
`float` - числа с плавающей точкой в диапазоне от `-1.79E+308` до `-2.23E-308` и от `2.23E-308` до `1.79E+308`

`float(n)` — n это точность числа от 1 до 24 и выделяется 4 байта для хранения числа с точностью до 7 знаков. 
Если n в диапазоне от 25 до 53, то выделяется 8 байт и точность 15 знаков. По умолчанию n = 53.

`real` = `float(24)` -3.40E+38 до -1,18E-38, 0, от 1,18E-38 до 3.40E+38


## Типы данных для хранения даты и времени
https://ru.wikipedia.org/wiki/Проблема_2038_года

`datetime` — хранит дату и время в в 24-часовом формате с указанием долей секунды в диапазоне с 1 января 1753 по 31 декабря 9999 года, 2017-12-28 15:20:35.693

`datetime2` — хранит дату и время в 24-часовом формате, но с большей точностью долей секунды по сравнению с типом datetime и диапазон дат
- 0001-01-01
- 9999-12-31
пример: 2024-08-22 20:37:35.1234567

`datetimeoffset`  - дата и время в 24-часовом формате с указанием долей секунды с учётом часового пояса в диапазоне
- 0001-01-01
- 9999-12-31
Пример: 2024-08-22 20:37:35.1234567 + 00:00

`smalldatetime` — только дата и время в 24-часовом формате с секундами всегда равными нулю, без долей секунды. Например для хранения времени покупок
- 1900-01-01
- 2079-06-06
Пример: 2024-08-22 20:58:00

`date` — хранение только даты, например дни рождения
- 0001-01-01
- 9999-12-31
Пример: 2024-08-22
YYYY-MM-DD

`time` — хранение только времени в 24-часовом формате с указанием долей секунды без учёта часового пояса
- 00:00:00.0000000
- 23:59:59.9999999

## Типы данных с фиксированной точкой
p - общее количество цифр
s - количество цифр дробной части

decimal(p, s)

numeric(p, s)

## Остальные типы данных
money - 8 байт
smallmoney - 4 байта

binary(n)

varbinary(n|max) 

geometry (двумерная декартова система координат)
geography (система координат широты и долготы)

xml

table - временный результирующий набор данных, полученных в результате запроса. 

# Индекс
Индекс - физическая структура данных в БД, при помощи которой осуществляется ускоренный доступ к информации.


# Запросы
Разница для вас не в стандартах SQL, а в диалектах
T-SQL (TransactSQL) - диалект в СУБД Microsoft SQL Server

PLpg/SQL (Procedural Language/postgreSQL) - диалект в СУБД PostgreSQL (постгря)

TransactSQL позволяет использовать операторы
- арифметические операторы `+ - * / %`
- логические операторы `(AND OR NOT)`
- операторы сравнения `=, >, <, >=, <=, <>`
- операторы для работы со множествами `IN`
- оператор создания переменной DECLARE
- условный оператор `IF` и цикл `WHILE`
- вызов встроенных функций: COUNT, SUM, MIN, MAX, DATEDIFF, ABS …
- комментирование строк кода через `--` либо блочный `/*…*/`

DDL операторы:
- CREATE
- ALTER
- DROP

DML операторы
- SELECT
- INSERT
- UPDATE
- DELETE

DCL операторы
- GRANT
- DENY
- REVOKE

## Оператор SELECT
считывает информацию из БД
## Оператор FROM
используется для указания источника получения данных

SELECT и FROM работают вместе
Пример синтаксиса
```sql
SELECT column1, column2, …
FROM tableName;
```

Запрос к таблице с выводом итогового названия столбца как алиас с пробелами:
```sql
SELECT LastName + ' ' + FirstName AS FullName, 
	Grants*0.87 AS [Inflation Rated Grants]
FROM Students;
```

## Оператор CAST
CAST осуществляет приведение данных к требуемому типу.
Формат записи оператора `CAST([Attribute] AS [TYPE])`

```sql
SELECT CAST(id AS nvarchar(3)) + ': ' + LastName AS query_id
FROM Students;
```

## Оператор CONVERT
CONVERT осуществляет приведение данных к требуемому типу.
Формат записи оператора `CONVERT([TYPE], [Attribute])`

```sql
SELECT CONVERT(nvarchar(3), id) + ': ' + LastName AS query_id
FROM Students;
```

## Оператор TOP
Первые N записей в SELECT
```sql
SELECT TOP N column1, column2, …
FROM tableName;
```
где N это целое число

### TOP N PERCENT
Получить N процентов первых записей из таблицы с округлением в большую сторону. 
```sql
SELECT TOP 40 PERCENT column1, column2, …
FROM tableName;
```

## Оператор DISTINCT
Отделить повтор данных
```sql
SELECT DISTINCT column1
FROM tableName;
```

## Оператор WHERE
Фильтрация получаемых данных.
Фильтр по дате
```sql
SELECT *
FROM Students
WHERE BirthDate > '1999-01-01';
```

- = равно
- `<>` не равно или `!=`
- `>` больше
- `>=` больше или равно
- `!>` не больше чем
- `<` меньше
- `<=` меньше или равно
- `!<` не меньше чем
## Функция LEN()
`LEN(строка)` - возвращает длину строки
```sql
SELECT *
FROM Students
WHERE LEN(FirstName) > 4 ;
```
## Функция YEAR(), MONTH(), DAY()

```sql
SELECT *
FROM Students
WHERE YEAR(BirthDate) = 2000;
```

```sql
SELECT *
FROM Students
WHERE MONTH(BirthDate) = 1;
```

```sql
SELECT *
FROM Students
WHERE DAY(BirthDate) = 1;
```

## Оператор ORDER BY
По умолчанию ORDER BY сортирует как ASC (по возрастанию)
```sql
SELECT TOP (5) *
FROM Students
ORDER BY LastName ASC
```

```sql
SELECT TOP (5) *
FROM Students
ORDER BY LastName DESC
```

Множественная сортировка по нескольким столбцам работает справа налево, то есть сначала LastName, потом BirthDate
```sql
SELECT TOP (5) *
FROM Students
ORDER BY BirthDate ASC, LastName ASC;
```

## Ключевое слово IN
Проверка условия на вхождение значений в указанное множество.
```sql
SELECT TOP (5) *
FROM Students
WHERE FirstName IN ('Anton','Oleg');
```

## Ключевые слова BETWEEN, AND, OR
> [!important] Вспомнить круги Эйлера

Логическое И
```sql
SELECT TOP (5) *
FROM Students
WHERE FirstName IN ('Anton','Oleg') AND LastName IN ('Martynenko','Zadornov');
```
Логическое ИЛИ
```sql
SELECT TOP (5) *
FROM Students
WHERE FirstName IN ('Anton','Oleg') 
	OR LastName IN ('Topova','Zadornov');
```

BETWEEN  ищет значения в диапазоне (включительно). Можно искать как по числам, так и по алфавиту конкретной СУБД
```sql
SELECT TOP (5) *
FROM Students
WHERE LastName BETWEEN 'D'
AND 'Zb';
```

NOT работает как отрицание заданного логического выражения
```sql
SELECT TOP (5) *
FROM Students
WHERE LastName NOT BETWEEN 'D'
AND 'Zb';
```

## Ключевое слово LIKE
LIKE позволяет применять шаблон к указанному атрибуту
Здесь ищем значение согласно регулярному выражению
```sql
SELECT TOP (5) *
FROM Students
WHERE FirstName LIKE '[A]%[a]';
```
подробно смотреть: [[Регулярные выражения]]

## Оператор INSERT

```sql
INSERT INTO tableName(columnName1, columnName2, …, columnName_N)
VALUES (value1, value2, …, value_N);
```
Записать две записи сразу
```sql
INSERT INTO Students(LastName, FirstName, BirthDate, Email)
VALUES ('Artemov', 'Boris', '1990-02-28', 'artemov_b@mail.ru');
INSERT INTO Students(LastName, FirstName, BirthDate, Email)
VALUES ('Artemov2', 'Bori2s', '1990-02-28', 'artemov_b2@mail.ru');
```
Пример скрипта без заголовков столбцов:
```sql
INSERT INTO Students
VALUES ('Wacko', 'Xzin', '2001-08-18', 1000 ,'Wacko_123@mail.com');
```

Вставка данных из другой таблицы 
```sql
INSERT INTO destinationTable
SELECT * 
FROM sourceTable
WHERE condition;
```
Вставка данных из другой таблицы метод 2 с указанием имён столбцов
```sql
INSERT INTO destinationTable(colName1, colName2,…,colName_N)
	SELECT colName1, colName2, … ,colName_N 
	FROM sourceTable
	WHERE condition;
```

## Оператор UPDATE
Обязательно используйте оператор WHERE, чтобы не перетереть важные данные!
```sql
UPDATE tableName
SET colName1 = value1, colName2 = value2, …
WHERE condition;
```
## Оператор DELETE
Удаляет ВСЕ данные, которые подходят под условие, например:
```sql
DELETE FROM Temp
WHERE id = 8;
```
## Полный скрипт создания таблицы как в классе
![[Скрипт создания таблицы как в классе#Скрипт создания таблицы как в классе]]

## Удалить таблицу при помощи скрипта

```sql
DROP TABLE TableName;
```
# Описание упражнения
https://sql-ex.ru/learn_exercises.php#answer_ref
Схема БД состоит из четырех таблиц:  
1. Product(maker, model, type)  
2. PC(code, model, speed, ram, hd, cd, price)  
3. Laptop(code, model, speed, ram, hd, price, screen)  
4. Printer(code, model, color, type, price)

таблица Printer

| code | model | color | type   | price    |
| ---- | ----- | ----- | ------ | -------- |
| 1    | 1276  | n     | Laser  | 400.0000 |
| 2    | 1433  | y     | Jet    | 270.0000 |
| 3    | 1434  | y     | Jet    | 290.0000 |
| 4    | 1401  | n     | Matrix | 150.0000 |
| 5    | 1408  | n     | Matrix | 270.0000 |
| 6    | 1288  | n     | Laser  | 400.0000 |


таблица Product

| maker | model | type    |
| ----- | ----- | ------- |
| A     | 1232  | PC      |
| A     | 1233  | PC      |
| A     | 1276  | Printer |
| A     | 1298  | Laptop  |
| A     | 1401  | Printer |
| A     | 1408  | Printer |
| A     | 1752  | Laptop  |
| B     | 1121  | PC      |
| B     | 1750  | Laptop  |
| C     | 1321  | Laptop  |
| D     | 1288  | Printer |
| D     | 1433  | Printer |
| E     | 1260  | PC      |
| E     | 1434  | Printer | 
| E     | 2112  | PC      |
| E     | 2113  | PC      |

> [!advice] Совет про нагрузку системы
> Учитывайте расписание выполнения скриптов от всех разработчиков, чтобы не попадать в периоды высокой нагрузки при работе с БД (или попадать, если так нужно).
> Самые популярные часы для пика нагрузки это 12 часов ночи и 12 часов дня в часовых поясах разработки, UTC+01 или часовых поясах пользователей. 

# Системные таблицы в СУБД
**backupfile** — содержит информацию обо всех файлах баз данных на момент создания резервных копий. Находится в системной базе данных *msdb*

**restorefile** — содержит информацию по каждому восстановленному файлу БД, расположена в базе данных *msdb*.

**log_shipping_promary_secondaries** — содержит информацию, которая связывает БД-источник с БД-получателем. Находится в системной базе данных *msdb*

**cdc.lsn_time_mapping** — в этой таблице хранятся данные о всех транзакциях из таблицы изменений. 

**MSdbms** — содержит полный список СУБД, отличных от MS SQL Server, который поддерживают совместимую с MS SQL Server репликацию баз данных. Находится в системной базе данных *msdb*

**MSreplication_options** — содержит данные, использующиеся при репликациях. Находится в системной базе данных *master*

**sys.sysoledbusers** — содержит данные по всем пользователям текущего сервера. Находится в системной базе данных *master*


Возможные нарушения при работе с базами данных:
- Чтение незафиксированных данных
- Неповторяемое чтение
- Фантомы
- Потерянные обновления

