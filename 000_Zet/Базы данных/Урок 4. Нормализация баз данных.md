# Целостность данных
Первоочерёдно целостность данных достигается за счёт проработки схем данных и ограничений на ввод информации в эти базы данных.
- `NOT NULL` — ограничение, что в текущий столбец обязательно будут записаны данные. Иначе транзакция будет отменена и СУБД вернёт ошибку. 
- `DEFAULT` — значение по умолчанию. 
- `CHECK` — ограничения с условиями проверки вводимых данных. 
- `UNIQUE` — ограничение на уникальность записанной информации.
- `PRIMARY KEY` — это поле автоматически в системе считается как UNIQUE и NOT NULL.
- `FOREIGN KEY`

# Нормализация
Эта концепция существует в реляционных базах данных.

Нормализованные данные это данные, организованные в структуру, которая обеспечивает целостность информации и сводит к минимуму количество избыточных данных.

Есть **Нормальные формы**. Записываются они сокращённо как 1NF, 2NF, 3NF, BCNF, 4NF, 5NF, DKNF, 6NF.

## Первая нормальная форма (1NF)

Требования к базе данных:
- каждое значение в записи должно быть атомарным (неделимым), то есть любой столбец в таблице, должен содержать только одно значение для каждой строки
- все записи в таблице должны быть разными, даже если в нескольких записях содержится одинаковая информация. *Подразумевается наличие первичного ключа*

## Вторая нормальная форма (2NF)
Функциональная зависимость — при существовании двух полей X и Y, поле X функционально зависит от Y, если с любым значением поля X, всегда связано ровно одно значение поля Y. 
Значения полей X и Y могут изменяться в течение времени, но только таким образом, чтобы любое поле X имело связанно с ним уникальное значение Y. 

X -> Y
Из X следует Y

Полная функциональная зависимость — если *ключевое поле* X состоит из нескольких полей, то *неключевое поле* Y должно функционально полно зависеть от X в целом и не зависеть функционально от какого-либо поля, входящего в него.

Частичная функциональная зависимость — зависимость *неключевого поля* от части составного поля. 

Неключевое поле — столбец, которые не входит в состав ни одного из возможных потенциальных ключей. 


Требования второй нормальной формы:
- таблица должна выполнять условия первой нормальной формы
- все столбцы, которые не входят в первичный ключ, должны зависеть от первичного ключа в целом, то есть должны быть связаны функциональной зависимостью с первичным ключом.

В этот момент таблица разделяется на несколько. 
Например, информация о факультете, группе или банке выносится в таблицы Faculties, Groups, Banks и т.д.

## Третья нормальная форма (3NF)

Транзитивная функциональная зависимость. 
Допустим, в таблице существуют три поля X, Y и Z. Функциональная зависимость между полями X и Z (X -> Z) называется транзитивной, если существуют зависимости между полями X и Y (X -> Y) и полями Y и Z (Y -> Z)

Требования к третьей нормальной форме:
- соответствие второй нормальной форме
- все столбцы, не входящие в первичный ключ, должны функционально зависеть только от первичного ключа и не зависеть от любого другого неключевого столбца.

# Многотабличные запросы
```sql
SELECT Attr_01_A, Attr_01_B, Attr_02_A, Attr_02_B
FROM Table_01, Table_02
WHERE Table_01.ForeignKey_02 = Table_02.ID
```

Если имя атрибута повторяется, то обязательно нужно указывать имя таблицы при написании атрибута. СУБД не поймёт ваш запрос иначе и выдаст ошибку. 

Псевдонимы — AS

Через псевдонимы можем сокращать имена таблиц и переназывать имена столбцов. 


В условии WHERE не обязательно используется равенство. Могут быть и логические операторы

```sql
SELECT Groups.Name AS GroupName, Faculties.Name AS FacultyName
FROM Groups, Faculties
WHERE Groups.Name LIKE '1%' 
	AND Faculties.Id=Groups.FacultyId
	AND Faculties.Name LIKE 'КТУ';
```

## Объединения
UNION 

JOIN 
![[Pasted image 20240905214737.png]]





`SQLore: обучение SQL` - приложения для Андроид и возможно для iPhone, где можно почитать про SQL и теорию баз данных и немного потренироваться. 



Пример объединения таблиц по INNER JOIN
```sql
SELECT t.name,
       COUNT(i.quantity)
FROM track AS t
INNER JOIN invoice_line AS i ON t.track_id=i.track_id
GROUP BY t.name
LIMIT 20;
```
> [!Summary]- Условие задачи:
> Нужно объединить данные двух таблиц: `track` и `invoice_line`. Таблица `track` хранит информацию о музыкальных треках в магазине, названия треков указаны в поле `name`. Таблица `invoice_line` содержит данные о купленных треках, их стоимость указана в поле `unit_price`. В обеих таблицах есть поле `track_id` — в нём содержатся идентификаторы музыкальных треков.
> 
> Выгрузите таблицу с названием трека и числом, которое соответствует тому, сколько раз трек покупали. Учитывайте, что в одном заказе один и тот же трек может встречаться несколько раз. Если какой-либо из треков не покупали или о купленном треке нет информации — такие записи не должны войти в таблицу. Оставьте в итоговой таблице первые 20 записей.


Пример использования INNER JOIN паровозиком
## Задача 2
```sql
SELECT t.name,
       COUNT(i.quantity),
       pt.playlist_id
FROM track AS t
INNER JOIN invoice_line AS i ON t.track_id=i.track_id
INNER JOIN playlist_track AS pt ON t.track_id=pt.track_id
GROUP BY t.name, pt.playlist_id
LIMIT 20;
```

> [!Summary]- Условие задачи
> Нужно дополнить запрос: добавьте поле с идентификатором плейлиста `playlist_id`. Такое поле можно получить из таблицы `playlist_track`. В этой таблице собраны идентификаторы плейлистов и треков (поле `track_id`). Условие остаётся прежним: если идентификаторы треков не совпадают во всех трёх таблицах, такие треки не должны войти в итоговую таблицу. Выведите первые 20 записей.


https://disk.yandex.ru/i/fMXpsnT1GtwZnw


## Задача 3

> [!Summary]- Условие задачи
> Идентификатор плейлиста теперь указан в итоговой таблице. Но что это за плейлисты — непонятно. Эту информацию можно взять в четвёртой таблице — playlist. Таблица содержит поле playlist_id с идентификатором плейлиста и поле name — с его названием. Добавьте в итоговую таблицу поле name. Условия те же: данные без совпадения не должны попасть в таблицу. Ограничьте вывод первыми 20 записями.

Решение:
```sql
SELECT t.name,
       SUM(i.quantity),
       pt.playlist_id,
       p.name
FROM track AS t
INNER JOIN invoice_line AS i ON t.track_id=i.track_id
INNER JOIN playlist_track AS pt ON t.track_id=pt.track_id
INNER JOIN playlist AS p ON pt.playlist_id = p.playlist_id
GROUP BY t.name, pt.playlist_id, p.name
LIMIT 20;
```

## Задача 4.

> [!Summary]- Условие задачи
> Теперь проанализируйте получившуюся таблицу. Нужно посчитать суммарную стоимость треков для каждого плейлиста. Отобразите в таблице два поля: `playlist_name` с названием плейлиста и `total_revenue` с суммарной стоимостью. Отсортируйте данные по значению в поле `total_revenue` от большего к меньшему.

Решение:
```sql
SELECT p.name AS playlist_name,
       SUM(i.unit_price) AS total_revenue
FROM track AS t
INNER JOIN invoice_line AS i ON t.track_id=i.track_id
INNER JOIN playlist_track AS pt ON t.track_id=pt.track_id
INNER JOIN playlist AS p ON pt.playlist_id = p.playlist_id
GROUP BY playlist_name
ORDER BY total_revenue DESC;
```

## Задача 5.
> [!Summary]- Условие задачи
> Массовую любовь к музыке 90-х можно понять. А как обстоит дело с жанрами — какие популярнее? Сгруппируйте данные по жанрам и посчитайте количество заказов. Выведите на экран два поля: одно с названием жанра, второе — с количеством купленных треков в этом жанре. Отсортируйте таблицу по убыванию количества заказов. 


```sql
SELECT g.name,
       COUNT(i.invoice_id) AS all_count
FROM invoice AS i 
JOIN invoice_line AS il ON i.invoice_id=il.invoice_id
JOIN track AS t ON il.track_id=t.track_id
JOIN genre AS g ON t.genre_id=g.genre_id
GROUP BY g.name
ORDER BY all_count DESC;
```

## Задача 6

Отберите названия уникальных категорий фильмов, в которых снималась Эмили Ди (англ. Emily Dee).

```sql
SELECT DISTINCT c.name
FROM actor AS a
    JOIN film_actor AS fa ON a.actor_id=fa.actor_id
    JOIN film_category AS fc ON fa.film_id=fc.film_id
    JOIN category AS c ON fc.category_id = c.category_id
WHERE first_name = 'Emily' AND last_name = 'Dee';
```

Пример на основе этой задачи для лучшего понимания паровозика джойнов

```sql
SELECT *
FROM actor AS a
    JOIN film_actor AS fa ON a.actor_id=fa.actor_id
    JOIN film_category AS fc ON fa.film_id=fc.film_id
    JOIN category AS c ON fc.category_id = c.category_id
WHERE first_name = 'Penelope' AND last_name = 'Guiness';
```

## LEFT JOIN

Выведите названия всех треков, добавив информацию о датах, в которые эти треки покупали. Ни один трек не должен потеряться, даже если его не покупали вообще. Чтобы получить нужный результат, надо соединить три таблицы сразу, ведь таблица `invoice`, которая хранит данные о дате заказа, не содержит информации о купленных треках.

Сначала соедините таблицы `track` и `invoice_line` по ключу `track_id`, а затем присоедините таблицу `invoice` по ключу `invoice_id`. В итоговую таблицу поместите два поля: `name` из таблицы `track` и `invoice_date` из таблицы `invoice`. Приведите дату в нужный формат.

```sql
SELECT name,
	   CAST(i.invoice_date AS date)       
FROM track AS t
LEFT JOIN invoice_line AS il ON t.track_id = il.track_id
LEFT JOIN invoice AS i ON il.invoice_id = i.invoice_id;
```

